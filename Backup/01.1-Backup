#!/bin/bash

# Backup script for Docker containers
# Configuration file format:
# Line 1: source directory
# Line 2: destination directory  
# Line 3: UUID of backup disk
# Line 4: mount point for backup disk

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Read configuration
CONFIG_FILE="/srv/containers/scripts/config/backupcont"
if [[ ! -f "$CONFIG_FILE" ]]; then
    echo "ERROR: Configuration file not found: $CONFIG_FILE"
    exit 1
fi

source=$(sed -n '1p' "$CONFIG_FILE" | tr -d '\r\n')
destiny=$(sed -n '2p' "$CONFIG_FILE" | tr -d '\r\n')
UUIDD=$(sed -n '3p' "$CONFIG_FILE" | tr -d '\r\n')
mountpoint=$(sed -n '4p' "$CONFIG_FILE" | tr -d '\r\n')

# Validate configuration
if [[ -z "$source" || -z "$destiny" || -z "$UUIDD" || -z "$mountpoint" ]]; then
    echo "ERROR: Invalid configuration. All fields must be filled."
    exit 1
fi

datetime=$(date +"%d_%m_%y")
SCRIPT_NAME=$(basename "$0")

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $SCRIPT_NAME: $1"
}

# Check if running as root
function checkRoot {
    if [[ "$EUID" -ne 0 ]]; then
        log "ERROR: This script must be run as root"
        exit 1
    fi
    log "Root privileges confirmed"
}

# Mount backup disk and perform backup
function mountAndBackup {
    log "Attempting to mount backup disk (UUID: $UUIDD)"
    
    # Check if already mounted
    if mountpoint -q "$mountpoint"; then
        log "Backup disk already mounted at $mountpoint"
    else
        # Create mountpoint if it doesn't exist
        mkdir -p "$mountpoint"
        
        # Mount the disk
        if mount -U "$UUIDD" "$mountpoint"; then
            log "Successfully mounted backup disk"
        else
            log "ERROR: Failed to mount backup disk"
            exit 1
        fi
    fi
    
    # Verify mount and destination
    if [[ ! -d "$mountpoint" ]] || ! mountpoint -q "$mountpoint"; then
        log "ERROR: Mount point verification failed"
        exit 1
    fi
    
    # Stop Docker containers
    log "Stopping Docker containers"
    if ! dockerControl stop; then
        log "ERROR: Failed to stop Docker containers"
        exit 1
    fi
    
    # Perform backup operations
    cleanupOldFiles
    performBackup
    
    # Start Docker containers
    log "Starting Docker containers"
    if ! dockerControl start; then
        log "WARNING: Failed to start Docker containers"
    fi
    
    log "Backup process completed successfully"
}

# Control Docker containers
function dockerControl {
    local action="$1"
    local containers
    
    containers=$(docker ps -aq)
    if [[ -z "$containers" ]]; then
        log "No Docker containers found"
        return 0
    fi
    
    log "Docker $action: $(echo "$containers" | wc -l) containers"
    
    # Use timeout to prevent hanging
    if timeout 120 docker "$action" $containers; then
        log "Docker $action completed successfully"
        return 0
    else
        log "ERROR: Docker $action failed or timed out"
        return 1
    fi
}

# Clean up old backup files
function cleanupOldFiles {
    log "Cleaning up files older than 3 days in $destiny"
    
    if [[ ! -d "$destiny" ]]; then
        log "Creating destination directory: $destiny"
        mkdir -p "$destiny"
    fi
    
    # Set appropriate permissions (755 is safer than 777)
    chmod 755 "$destiny"
    
    # Delete files older than 3 days
    local deleted_count
    deleted_count=$(find "$destiny" -type f -mtime +3 -print0 | xargs -0 rm -f | wc -l)
    log "Deleted $deleted_count old backup files"
}

# Perform the actual backup
function performBackup {
    log "Starting backup process"
    
    # Verify source directory exists
    if [[ ! -d "$source" ]]; then
        log "ERROR: Source directory does not exist: $source"
        exit 1
    fi
    
    # Create compressed archives for each container directory
    log "Creating compressed archives"
    local archive_count=0
    
    for container_dir in /srv/containers/*/; do
        if [[ -d "$container_dir" ]]; then
            local container_name
            container_name=$(basename "$container_dir")
            local archive_name="$destiny/${container_name}-${datetime}.tar.lz4"
            
            log "Archiving: $container_dir -> $archive_name"
            
            if tar -I 'lz4 -1 -c' -cpf "$archive_name" -C "$(dirname "$container_dir")" "$container_name"; then
                ((archive_count++))
                log "Successfully created archive: $archive_name"
            else
                log "ERROR: Failed to create archive for $container_dir"
            fi
        fi
    done
    
    log "Created $archive_count container archives"
    
    # Sync source to destination using rsync
    log "Syncing source directory to destination"
    if rsync -av --delete --stats "$source/" "$destiny/sync/"; then
        log "Rsync completed successfully"
    else
        log "ERROR: Rsync failed"
        exit 1
    fi
}

# Cleanup function for script exit
function cleanup {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        log "Script exited with error code: $exit_code"
        # Attempt to start containers if they were stopped
        if command -v docker >/dev/null 2>&1; then
            log "Attempting to restart Docker containers after error"
            dockerControl start || true
        fi
    fi
}

# Set up trap for cleanup
trap cleanup EXIT

# Main execution
function main {
    log "Starting backup script"
    log "Source: $source"
    log "Destination: $destiny"
    log "Mount point: $mountpoint"
    
    checkRoot
    mountAndBackup
    
    log "Backup script completed successfully"
    exit 0
}

# Execute main function
main "$@"
